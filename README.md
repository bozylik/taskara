# taskara
[![Go Report Card](https://goreportcard.com/badge/github.com/bozylik/taskara)](https://goreportcard.com/report/github.com/bozylik/taskara)
[![Go Coverage](https://img.shields.io/badge/coverage-96%25-brightgreen)](https://github.com/bozylik/taskara)
[![GitHub tag (latest by date)](https://img.shields.io/github/v/tag/bozylik/taskara?color=blue&label=version)](https://github.com/bozylik/taskara/tags)
[![Go Reference](https://pkg.go.dev/badge/github.com/bozylik/taskara.svg)](https://pkg.go.dev/github.com/bozylik/taskara)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

### lightweight task scheduler with priority and worker pool

taskara is a simple and fast library for managing tasks in go. it allows you to run many tasks concurrently using a controlled number of workers. it is designed to be minimal, having zero external dependencies.

---

> [!IMPORTANT]
> ## alpha-build
> this is an alpha version of the project.<br>
> **status:** under active development.<br>

---

## navigation
* [features](#features)
* [architecture & resource usage](#architecture)
* [methods and functions](#methods-and-functions)
* [core concepts & usage](#core-concepts--usage)
* [examples](#examples)

---

## features

* **worker pool:** limit the number of active goroutines to save resources.
* **priority queue:** important tasks are executed first.
* **scheduling:** start tasks immediately or at a specific time.
* **timeouts:** automatically cancel tasks that take too long.
* **individual control:** cancel a specific task by its id without stopping others.
* **easy integration:** get results through go channels.
* **panic recovery:** automatically catches panics inside tasks, reporting them as errors without crashing the worker pool.
* **advanced retries:** flexible retry strategies (fixed, linear, or exponential backoff) to handle transient failures.
* **lifecycle callbacks:** register `OnComplete` and `OnFailure` hooks to react to task results or errors instantly.

---

## architecture

the system consists of three main parts:
1. **scheduler:** manages the waiting and ready queues using a priority heap.
2. **executor:** runs a fixed pool of workers that process tasks.
3. **cluster:** provides a simple interface to submit and manage tasks.

### resource usage
to ensure isolation and robust error handling, taskara uses a supervisor-worker pattern. for every worker in the cluster, there are two active goroutines:
* **the worker:** manages the task lifecycle and waits for new jobs.
* **the supervisor:** executes the actual `TaskFunc`, handles timeouts, and catches panics.

including the main scheduler, the total number of goroutines is calculated as:
$2n + 1$ (where $n$ is the number of workers).

---

## methods and functions

>**task (package functions)**<br>

These functions are called directly from the task package.

`NewTask(id string, fn TaskFunc) TaskInterface` - function (constructor), creates a new task instance.<br>
> [!NOTE]
> If you leave the id empty, a unique ID will be automatically generated by the cluster during the `Submit()` call.<br>

>**TaskInterface (methods)**<br>

These methods are available on a task instance.

`ID() string` - Returns the task's unique identifier.<br>
`SetID(id string)` - Updates the task ID manually.<br>
`Fn() TaskFunc` - Returns the underlying task function.<br>
`Clone() TaskInterface` - Creates a deep copy of the task.<br>
> [!NOTE]
> The cluster calls this automatically during `AddTask` to ensure that each execution has its own independent state and to prevent side effects from external modifications.

>**cluster (package functions)**<br>

`NewCluster(workers int, ctx context.Context) ClusterInterface` - function (constructor), creates a new cluster instance.<br>

>**ClusterInterface (methods)**<br>

`Run()` - Starts the cluster's execution engine. Workers begin listening to the queue and processing tasks.<br>
> [!NOTE]
> Tasks will remain in the queue and won't start until Run() is called.

`AddTask(t task.TaskInterface) ClusterTaskBuilderInterface` - The entry point for submitting a task. It returns a builder that allows you to configure scheduling, timeouts, and metadata. You must call `.Submit()` at the end of the chain to queue the task.<br>
`Subscribe(id string) (<-chan Result, error)`- Returns a channel that receives the task's result (`val` and `err`).<br>
> [!WARNING]
> Timing is key: By default, you must subscribe before the task completes. To retrieve results for already finished tasks, the task must be marked as `.IsCacheable(true)` during submission.<br>

> [!IMPORTANT]
> **Avoid deadlocks**: If your task logic (the `TaskFunc`) blocks and waits for a result from `Subscribe`, and all workers in the pool are occupied by similar tasks, you will hit a deadlock. Ensure that result consumption happens in a separate goroutine or that the worker pool is large enough.<br>

> [!NOTE]
> **Channel safety**: Always check if the returned channel is not `nil` and handle the `error` returned by the method. A nil channel is returned only if the error is not `nil`.<br>

`CancelTask(id string)` - Targets and cancels a specific task by its ID. This triggers the `cancelled` channel inside the `TaskFunc` and closes the task's context.<br>
`Stop(timeout time.Duration) error` - **Graceful shutdown**. The cluster stops accepting new tasks and waits for active workers to finish. If the timeout is reached before tasks finish, it returns an error.<br>
`Cancel()` - **Immediate shutdown**. Instantly kills all workers and cancels all active task contexts.<br>
> [!CAUTION]
> Use this only when a graceful shutdown is not possible, as it may leave tasks in an incomplete state.

>**ClusterTaskBuilderInterface (methods)**<br>

These methods allow you to configure a task's behavior before adding it to the queue. They support method chaining.

`WithStartTime(st time.Time) ClusterTaskBuilderInterface` - Schedules the task to run at a specific time. If the time is in the past or `time.Now()`, the task will be executed as soon as a worker is available.<br>
`WithTimeout(tm time.Duration) ClusterTaskBuilderInterface` - Sets a maximum execution time for the task. If the task exceeds this duration, its `ctx` will be cancelled, and the task will be marked as timed out.<br>
`WithPriority(p int) ClusterTaskBuilderInterface` - Sets the task's priority. Higher values (or lower, depending on your heap logicâ€”usually higher) will move the task to the front of the queue.<br>
> [!TIP]
> **How scheduling priority works?**
>
> **Time first**: The scheduler primarily looks at the `StartTime`. A task scheduled for "now" will always beat a task scheduled for "in 5 minutes," regardless of priority.<br>
> **Priority as a tie-breaker**: If two tasks have the same `StartTime`, the one with the higher priority will be executed first.<br>
> **Order of submission**: If both `StartTime` and `Priority` are identical, the task that was submitted first (FIFO) will typically take precedence.<br>

`IsCacheable(v bool) ClusterTaskBuilderInterface` - Determines if the task result should be stored in memory after completion.<br>
> [!TIP]
> **Retention Policy**: Currently, cached results are stored for 5 minutes after the task completes. After this period, the result is purged from memory to prevent leaks. (Note: This duration may become configurable in future releases).<br>

`WithRetry(r int) ClusterTaskBuilderInterface` - Sets the maximum number of times a task will be retried upon failure. Default is 0 (no retries).<br>
`WithBackoffStrategy(strategy RetryBackoffStrategy) ClusterTaskBuilderInterface` - Defines the delay logic between retry attempts. Default is `FixedBackoff` with 0s delay if not specified.<br>
`WithJitter() ClusterTaskBuilderInterface` - Adds a small random variation to the retry delay to prevent thundering herd problems.<br>
`RetryIf(func(err error) bool) ClusterTaskBuilderInterface` - Registers a predicate function to decide whether a retry should be attempted based on the error. If the function returns true, the task is retried; otherwise, it fails immediately.<br>
`WithRetryMode(mode RetryMode) ClusterTaskBuilderInterface` - Defines where the retry delay happens. Default is `Requeue` (returns the task to the queue).<br>

`OnComplete(fn func(id string, val any, err error)) ClusterTaskBuilderInterface` - OnComplete registers a callback that will be invoked once the task finishes its execution, regardless of whether it succeeded, failed, or was cancelled.<br>
`OnFailure(fn func(id string, err error)) ClusterTaskBuilderInterface` - Registers a callback that will be invoked only if the task ends with an error, a panic, or is cancelled.<br>

`Submit() (string, error)` - The final method in the chain. It validates the task, generates an ID (if empty), and pushes the task into the scheduler.<br>
> [!WARNING]
> Returns an error if a task with the same ID is already running or managed by the cluster.<br>

> Backoff Strategy (cluster package)

Taskara provides a flexible system for handling delays between retry attempts. You can use the built-in strategies or implement your own by satisfying the `RetryBackoffStrategy` interface.

> RetryBackoffStrategy (interface)

`Next(attempt int) time.Duration` - Calculates the duration to wait before the next attempt, given the current attempt number.<br>

> Built-in Strategies (constructors)

`NewFixedBackoff(delay time.Duration) RetryBackoffStrategy` - Creates a strategy that always returns the same constant delay.<br>
> [!TIP] 
> Use this for simple tasks where the recovery time of the external system is predictable.

`NewLinearBackoff(base time.Duration, step time.Duration) RetryBackoffStrategy` - Creates a strategy where the delay increases by a fixed step after each attempt: `Base + (Step * attempt)`.<br>
`NewExponentialBackoff(base time.Duration, multiplier float64, max time.Duration) RetryBackoffStrategy` - Creates a strategy where the delay grows exponentially: `Base * (Multiplier ^ attempt)`. 
The factor by which the delay grows (defaults to 2.0 if set below 1.0). An upper bound to ensure the delay doesn't grow indefinitely. <br>
> [!IMPORTANT] 
> **Recommended for Network Ops**: This is the best strategy for API calls and microservices to prevent "thundering herd" issues when a remote service is struggling.

> RetryMode (types)
> 
These constants define how the worker pool handles the delay between retries.

`Requeue` - Asynchronous Retry. The task is sent back to the scheduler. The current worker is freed immediately to pick up other tasks, and the failed task will only be picked up again after its backoff delay expires.<br>
> [!TIP]
> This is the default and most efficient mode for most cases, as it maximizes worker availability.

`Immediate` - Synchronous Retry. The worker stays "locked" to the task. It will sleep for the duration of the backoff delay and then execute the task again.
> [!CAUTION] 
> Use this only for critical tasks. If too many tasks use Immediate mode with long delays, you can exhaust your worker pool, leaving no workers available for other tasks.

---

## core concepts & usage

>**installation**<br>

`go get github.com/bozylik/taskara@v0.0.2-alpha`

Usage:
```go
import (
"github.com/bozylik/taskara/task"
"github.com/bozylik/taskara/cluster"
)
```

>**part 1: TaskFunc (job)**<br>

**TaskFunc** - is a type from the `taskara/task` package that defines the function (job) to be executed:<br>
`type TaskFunc func(id string, workerCtx context.Context, cancelled <-chan struct{}, report Reporter)`<br>
| Argument | Type | Description |
| :--- | :--- | :--- |
| **id** | `string` | The unique identifier of the task |
| **ctx** | `context.Context` | General context. Triggers on **manual cancel**, **timeout**, and **cluster shutdown** |
| **cancelled** | `<-chan struct{}` | Special channel. Triggers **on manual user cancellation** via `CancelTask()` and **cluster shutdown** |
| **report** | `Reporter` | Callback function to send results and errors back to the cluster |

`type Reporter func(id string, val any, err error)` - reporter is a callback used to send results back to the cluster.
| Argument | Type | Description |
| :--- | :--- | :--- |
| **id** | `string` | The unique task identifier (passed from `TaskFunc`) |
| **val** | `any` | Any data you want to return as a result (`interface{}`) |
| **err** | `error` | An error object if the task failed, otherwise `nil` |

  ```go
  job1 := func(id string, ctx context.Context, cancelled <-chan struct{}, report task.Reporter) {

select {
case <-cancelled:
return
case <-ctx.Done():
fmt.Println("timeout")
return
case <-time.After(4 * time.Second):
fmt.Printf("[%s] Working job1...\n", id)
}

report(id, "Data from task-1", nil)
}
  ```
>[!TIP]
>Why two signals? Use `ctx.Done()` for general cleanup. Use cancelled only if you need to distinguish a manual user "Abort" from a timeout. If you return without calling `report()`, the cluster will automatically finalize the task with nil results.<br>

>**part 2: task and TaskInterface**<br>

A task is a base struct used within clusters. It contains a unique ID and the function to be executed.<br>
**task** - struct with `id string` and `fn TaskFunc` fields.<br>
**TaskInterface** - interface that provides encapsulation for task methods.<br>
```go
task1 := task.NewTask("", job1)
// or specify a custom ID
task1 := task.NewTask("task-1", job1)
```

>**part 3: cluster and ClusterInterface**<br>

The Cluster manages task execution. It contains all necessary methods for running, cancelling tasks, and the cluster itself.<br>
**cluster** - struct that contains executor, scheduler, and state.<br>
**ClusterInterface** - interface that provides encapsulation for cluster methods.<br>
```go
// Cluster context
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

// Create cluster with 2 active workers
myCluster := cluster.NewCluster(2, ctx)
myCluster.Run()
```
>**part 4: clusterTask and clusterTaskBuilder**<br>

**Result** is what you get from the subscription channel.
```go
type Result struct {
Result any   // Data from the task
Err    error // Error from the task, timeout, or panic
}
```

**clusterTask** - is an internal task struct that represents a task within the cluster's lifecycle.<br>
**clusterTaskBuilder** - is a helper that allows you to use chaining while adding a new task.<br>

```go
clusterTaskID, err := myCluster.AddTask(task1).
WithStartTime(time.Now().Add(5 * time.Second)).
WithTimeout(5 * time.Second).
IsCacheable(true).
Submit()

if err != nil {
// Panic for example
panic(err)
}

resChan, err := myCluster.Subscribe(clusterTaskID)
if err != nil {
// Panic for example
panic(err)
}

fmt.Println("Results:", <-resChan)
```

---

## examples

Check out our [usage examples](https://github.com/bozylik/taskara/tree/main/examples), to see more complex use cases and implementation details.
